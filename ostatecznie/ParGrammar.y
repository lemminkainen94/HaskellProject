-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParGrammar where
import AbsGrammar
import LexGrammar
import ErrM

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '*' { PT _ (TS _ 3) }
  '+' { PT _ (TS _ 4) }
  ',' { PT _ (TS _ 5) }
  '-' { PT _ (TS _ 6) }
  '.' { PT _ (TS _ 7) }
  '/' { PT _ (TS _ 8) }
  ':' { PT _ (TS _ 9) }
  ';' { PT _ (TS _ 10) }
  '<' { PT _ (TS _ 11) }
  '<=' { PT _ (TS _ 12) }
  '<>' { PT _ (TS _ 13) }
  '=' { PT _ (TS _ 14) }
  '==' { PT _ (TS _ 15) }
  '>' { PT _ (TS _ 16) }
  '>=' { PT _ (TS _ 17) }
  '[' { PT _ (TS _ 18) }
  ']' { PT _ (TS _ 19) }
  'and' { PT _ (TS _ 20) }
  'array' { PT _ (TS _ 21) }
  'begin' { PT _ (TS _ 22) }
  'bool' { PT _ (TS _ 23) }
  'do' { PT _ (TS _ 24) }
  'downto' { PT _ (TS _ 25) }
  'else' { PT _ (TS _ 26) }
  'end' { PT _ (TS _ 27) }
  'for' { PT _ (TS _ 28) }
  'function' { PT _ (TS _ 29) }
  'if' { PT _ (TS _ 30) }
  'int' { PT _ (TS _ 31) }
  'mod' { PT _ (TS _ 32) }
  'not' { PT _ (TS _ 33) }
  'or' { PT _ (TS _ 34) }
  'print' { PT _ (TS _ 35) }
  'program' { PT _ (TS _ 36) }
  'record' { PT _ (TS _ 37) }
  'return' { PT _ (TS _ 38) }
  'then' { PT _ (TS _ 39) }
  'to' { PT _ (TS _ 40) }
  'type' { PT _ (TS _ 41) }
  'var' { PT _ (TS _ 42) }
  'void' { PT _ (TS _ 43) }
  'while' { PT _ (TS _ 44) }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_Logical { PT _ (T_Logical $$) }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Logical    :: { Logical} : L_Logical { Logical ($1)}

Program :: { Program }
Program : ProgramHeading DeclarationPart StatementPart '.' { AbsGrammar.Prog $1 $2 $3 }
ProgramHeading :: { ProgramHeading }
ProgramHeading : 'program' Ident ';' { AbsGrammar.ProgHead $2 }
DeclarationPart :: { DeclarationPart }
DeclarationPart : TypeDefinitionPart VariableDeclarationPart FunctionDeclarationPart { AbsGrammar.DeclPart $1 $2 $3 }
TypeDefinitionPart :: { TypeDefinitionPart }
TypeDefinitionPart : {- empty -} { AbsGrammar.TypeDefPartEmpty }
                   | 'type' ListRecordDefinition { AbsGrammar.TypeDefPart (reverse $2) }
RecordDefinition :: { RecordDefinition }
RecordDefinition : 'record' Ident ListField 'end' { AbsGrammar.RecDef $2 $3 }
Field :: { Field }
Field : 'int' ListIdent { AbsGrammar.IntRecFld $2 }
      | 'bool' ListIdent { AbsGrammar.LogicRecFld $2 }
VariableDeclarationPart :: { VariableDeclarationPart }
VariableDeclarationPart : {- empty -} { AbsGrammar.VarDeclPartEmpty }
                        | 'var' ListVariableDeclaration { AbsGrammar.VarDeclPart $2 }
VariableDeclaration :: { VariableDeclaration }
VariableDeclaration : Type Ident { AbsGrammar.VarDecl $1 $2 }
FunctionDeclarationPart :: { FunctionDeclarationPart }
FunctionDeclarationPart : ListFunctionDeclaration { AbsGrammar.FunDeclPart (reverse $1) }
FunctionDeclaration :: { FunctionDeclaration }
FunctionDeclaration : FunctionHeading ';' FunctionBody { AbsGrammar.FunDecl $1 $3 }
FunctionHeading :: { FunctionHeading }
FunctionHeading : 'function' Ident FormalParameterList ':' Type { AbsGrammar.FunHead $2 $3 $5 }
FormalParameterList :: { FormalParameterList }
FormalParameterList : '(' ListFormalParameterSection ')' { AbsGrammar.FormalParamList $2 }
FormalParameterSection :: { FormalParameterSection }
FormalParameterSection : Type Ident { AbsGrammar.ValParamSect $1 $2 }
                       | 'var' Type Ident { AbsGrammar.VarParamSect $2 $3 }
FunctionBody :: { FunctionBody }
FunctionBody : VariableDeclarationPart FunctionStatementPart { AbsGrammar.FunBody $1 $2 }
FunctionStatementPart :: { FunctionStatementPart }
FunctionStatementPart : 'begin' ListStatement ReturnStatement 'end' { AbsGrammar.FunStmtPart (reverse $2) $3 }
ReturnStatement :: { ReturnStatement }
ReturnStatement : 'return' ';' { AbsGrammar.RetStmtEmpty }
                | 'return' Exp ';' { AbsGrammar.RetStmt $2 }
StatementPart :: { StatementPart }
StatementPart : 'begin' ListStatement 'end' { AbsGrammar.StmtPart (reverse $2) }
Statement :: { Statement }
Statement : Exp { AbsGrammar.ExpStmt $1 }
          | 'print' '(' Exp ')' { AbsGrammar.PrintStmt $3 }
          | Variable '=' Exp { AbsGrammar.AssignStmt $1 $3 }
          | 'while' Exp 'do' ListStatement { AbsGrammar.WhileStmt $2 (reverse $4) }
          | 'for' Ident '=' Exp 'to' Exp 'do' ListStatement { AbsGrammar.ForToStmt $2 $4 $6 (reverse $8) }
          | 'for' Ident '=' Exp 'downto' Exp 'do' ListStatement { AbsGrammar.ForDowntoStmt $2 $4 $6 (reverse $8) }
          | 'if' Exp 'then' ListStatement { AbsGrammar.IfStmt $2 (reverse $4) }
          | 'if' Exp 'then' ListStatement 'else' ListStatement { AbsGrammar.IfElseStmt $2 (reverse $4) (reverse $6) }
Exp :: { Exp }
Exp : Exp 'or' Exp1 { AbsGrammar.EOr $1 $3 } | Exp1 { $1 }
Exp1 :: { Exp }
Exp1 : Exp1 'and' Exp2 { AbsGrammar.EAnd $1 $3 } | Exp2 { $1 }
Exp2 :: { Exp }
Exp2 : Exp2 '<' Exp3 { AbsGrammar.ELess $1 $3 }
     | Exp2 '>' Exp3 { AbsGrammar.EGreater $1 $3 }
     | Exp2 '<=' Exp3 { AbsGrammar.ELessEqual $1 $3 }
     | Exp2 '>=' Exp3 { AbsGrammar.EGreaterEqual $1 $3 }
     | Exp2 '==' Exp3 { AbsGrammar.EEqual $1 $3 }
     | Exp2 '<>' Exp3 { AbsGrammar.ENonEqual $1 $3 }
     | Exp3 { $1 }
Exp3 :: { Exp }
Exp3 : Exp3 '+' Exp4 { AbsGrammar.EAdd $1 $3 }
     | Exp3 '-' Exp4 { AbsGrammar.ESub $1 $3 }
     | Exp4 { $1 }
Exp4 :: { Exp }
Exp4 : Exp4 '*' Exp5 { AbsGrammar.EMul $1 $3 }
     | Exp4 '/' Exp5 { AbsGrammar.EDiv $1 $3 }
     | Exp4 'mod' Exp5 { AbsGrammar.EMod $1 $3 }
     | Exp5 { $1 }
Exp5 :: { Exp }
Exp5 : '-' Exp5 { AbsGrammar.EMin $2 }
     | 'not' Exp5 { AbsGrammar.ENot $2 }
     | Variable { AbsGrammar.EVar $1 }
     | Ident '(' ListExp ')' { AbsGrammar.EFun $1 $3 }
     | Integer { AbsGrammar.EInt $1 }
     | Logical { AbsGrammar.ELogic $1 }
     | '(' Exp ')' { $2 }
Variable :: { Variable }
Variable : Ident { AbsGrammar.Var $1 }
         | Ident '[' Exp ']' { AbsGrammar.ArrayVariable $1 $3 }
         | Ident '.' Ident { AbsGrammar.FieldDes $1 $3 }
Type :: { Type }
Type : 'int' { AbsGrammar.IntType }
     | 'bool' { AbsGrammar.LogicType }
     | 'int' 'array' '[' Integer ']' { AbsGrammar.IntArrayType $4 }
     | 'bool' 'array' '[' Integer ']' { AbsGrammar.LogicArrayType $4 }
     | Ident { AbsGrammar.RecordType $1 }
     | 'void' { AbsGrammar.VoidType }
ListIdent :: { [Ident] }
ListIdent : Ident { (:[]) $1 } | Ident ',' ListIdent { (:) $1 $3 }
ListExp :: { [Exp] }
ListExp : {- empty -} { [] }
        | Exp { (:[]) $1 }
        | Exp ',' ListExp { (:) $1 $3 }
ListFormalParameterSection :: { [FormalParameterSection] }
ListFormalParameterSection : {- empty -} { [] }
                           | FormalParameterSection { (:[]) $1 }
                           | FormalParameterSection ',' ListFormalParameterSection { (:) $1 $3 }
ListField :: { [Field] }
ListField : Field { (:[]) $1 } | Field ';' ListField { (:) $1 $3 }
ListStatement :: { [Statement] }
ListStatement : {- empty -} { [] }
              | ListStatement Statement ';' { flip (:) $1 $2 }
ListRecordDefinition :: { [RecordDefinition] }
ListRecordDefinition : {- empty -} { [] }
                     | ListRecordDefinition RecordDefinition ';' { flip (:) $1 $2 }
ListVariableDeclaration :: { [VariableDeclaration] }
ListVariableDeclaration : VariableDeclaration ';' { (:[]) $1 }
                        | VariableDeclaration ';' ListVariableDeclaration { (:) $1 $3 }
ListFunctionDeclaration :: { [FunctionDeclaration] }
ListFunctionDeclaration : {- empty -} { [] }
                        | ListFunctionDeclaration FunctionDeclaration ';' { flip (:) $1 $2 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

